



Zkproof                                                          M. Orrù
Internet-Draft                                                      CNRS
Intended status: Informational                             26 March 2025
Expires: 27 September 2025


                       Fiat-Shamir Transformation
                 draft-orru-zkproof-fiat-shamir-latest

Abstract

   This document describes the Fiat-Shamir transformation via a duplex
   sponge interface that is capable of supporting a number of different
   hash functions, to "absorb" elements from different domains, and
   produce pseudoranom elements "squeezing" from the hash object.

   In addition, the specification provides codes, a way to absorb
   specific data types.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://mmaker.github.io/stdsigma/draft-orru-zkproof-fiat-
   shamir.html.  Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-orru-zkproof-fiat-shamir/.

   Discussion of this document takes place on the Crypto Forum mailing
   list (mailto:cfrg@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/cfrg.  Subscribe at
   https://www.ietf.org/mailman/listinfo/cfrg/.

   Source for this draft and an issue tracker can be found at
   https://github.com/mmaker/stdsigma.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 27 September 2025.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  The API
   3.  Duplex Sponges
     3.1.  Implementation
       3.1.1.  Initialization
       3.1.2.  Absorb
       3.1.3.  Squeeze
     3.2.  Ciphersuites
     3.3.  Keccak f-1600
     3.4.  SHAKE128 compatibility [WIP]
       3.4.1.  Initialization
       3.4.2.  Absorb
       3.4.3.  Squeeze
   4.  Codecs registry
     4.1.  P-384 (secp384r1)
       4.1.1.  Absorb scalars
       4.1.2.  Absorb elements
       4.1.3.  Squeeze scalars
   5.  Notation and Terminology
   6.  References
     6.1.  Normative References
     6.2.  Informative References
   Author's Address

1.  Introduction

   The Fiat-Shamir transformation relies on a hash function that can
   absorb inputs incrementally and squeeze variable-length unpredictable
   messages.  On a high level, it consists of three main components:

   *  A label.

   *  An underlying hash function H, in a chosen mode, which the hash
      state invokes to execute the actions.

   The core actions supported are:

   *  absorb indicates a sequence of len elements in input

   *  squeeze indicates an amount len of output to be produced

   The API follows the template of duplex sponges.

2.  The API

   A duplex sponge has the following interface:

   class DuplexSpongeInterface: type Unit

     def new(iv: bytes) -> hash_state
     def absorb(self, x)
     def squeeze(self, length: int) -> [Unit]
     def finalize(self)

   where

   *  DuplexSpongeInterface.init(label) -> hash_state, creates a new
      hash_state object with a description label label;

   *  DuplexSpongeInterface.absorb(hash_state, values), absorbs a list
      of native elements (that is, of type Unit);

   *  DuplexSpongeInterface.squeeze(hash_state, length), squeezes from
      the hash_state object a list of Unit elements.

   *  DuplexSpongeInterface.finalize(hash_state), deletes the hash
      object safely.

   The above can be extended to support absorption and squeeze from
   different domains.  Such extensions are called codecs.

3.  Duplex Sponges

   A duplex sponge in overwrite mode is based on a permutation function
   P that maps a vector of r + c elements of type Unit elements.

3.1.  Implementation

3.1.1.  Initialization

   new(iv)

   assert len(iv) == 32
   self.absorb_index = 0
   self.squeeze_index = 0
   self.rate = self.state.R
   self.capacity = self.state.N - self.state.R

3.1.2.  Absorb

   absorb(input)

   Inputs:
       self

   Outputs:

   Constants:
       permutation,


   self.squeeze_index = self.rate
   if len(input) == 0:
       return
   if 0 <= self.absorb_index < self.rate:
       self.state[self.absorb_index] = input[0]
       self.absorb_index += 1
       input = input[1:]
       return self.absorb(input)
   if self.absorb_index == self.rate:
       self.state.permute()
       self.absorb_index = 0
       return self.absorb(input)

3.1.3.  Squeeze

def squeeze(self, length: int):
    self.absorb_index = self.rate

    output = b''
    if length == 0:
        return output

    if 0 <= self.squeeze_index < self.rate:
        output += bytes(self.state[self.squeeze_index:self.squeeze_index+1])
        self.squeeze_index += 1
        length -= 1
        return output + self.squeeze(length)

    if self.squeeze_index == self.rate:
        self.state.permute()
        self.squeeze_index = 0
        return output + self.squeeze(length)

3.2.  Ciphersuites

3.3.  Keccak f-1600

3.4.  SHAKE128 compatibility [WIP]

   SHAKE128 is a variable-length hash function based on the Keccak
   sponge construction [SHA3].  It belongs to the SHA-3 family but
   offers a flexible output length, and provides 128 bits of security
   against collision attacks, regardless of the output length requested.

3.4.1.  Initialization

   new(self, label)

   Inputs:

   - label, a byte array

   Outputs:

   -  a hash state interface

   1. h = shake_128(label)
   2. return h

3.4.2.  Absorb

   absorb(hash_state, x)

   Inputs:

   - hash_state, a hash state
   - x, a byte array

   1. h.update(x)

   This method is also re-exported as absorb_bytes.

3.4.3.  Squeeze

   squeeze(hash_state, length)

   Inputs:

   - hash_state, the hash state
   - length, the number of elements to be squeezed

   1. h.digest(length)

   This method is also re-exported as squeeze_bytes.

4.  Codecs registry

4.1.  P-384 (secp384r1)

4.1.1.  Absorb scalars

   absorb_scalars(hash_state, scalars)

   Inputs:

   - hash_state, the hash state
   - scalars, a list of elements of P-384's scalar field

   Constants:

   - scalar_byte_length = ceil(384/8)

   1. for scalar in scalars:
   2.     hash_state.absorb_bytes(scalar_to_bytes(scalar))

   Where the function scalar_to_bytes is defined in {#notation}

4.1.2.  Absorb elements

   absorb_elements(hash_state, elements)

   Inputs:

   - hash_state, the hash state
   - elements, a list of P-384 group elements

   1. for element in elements:
   2.     hash_state.absorb_bytes(ecpoint_to_bytes(element))

4.1.3.  Squeeze scalars

 squeeze_scalars(hash_state, length)

 Inputs:

 - hash_state, the hash state
 - length, an unsiged integer of 64 bits determining the output length.

 1. for i in range(length):
 2.     scalar_bytes = hash_state.squeeze_bytes(field_bytes_length + 16)
 3.     scalars.append(bytes_to_scalar_mod_order(scalar_bytes))

5.  Notation and Terminology

   For an elliptic curve, we consider two fields, the coordinate fields,
   which indicates the field over which the elliptic curve equation is
   defined, and the scalar field, over which the scalar operations are
   performed.

   The following functions and notation are used throughout the
   document.

   *  concat(x0, ..., xN): Concatenation of byte strings.

   *  bytes_to_int and scalar_to_bytes: Convert a byte string to and
      from a non-negative integer. bytes_to_int and scalar_to_bytes are
      implemented as OS2IP and I2OSP as described in [RFC8017],
      respectively.  Note that these functions operate on byte strings
      in big-endian byte order.  These functions MUST raise an exception
      if the integer over which they We consider the function
      bytes_to_in

   *  The function ecpoint_to_bytes converts an elliptic curve point in
      affine-form into an array string of length
      ceil(ceil(log2(coordinate_field_order))/ 8) + 1 using int_to_bytes
      prepended by one byte.  This is defined as

      ecpoint_to_bytes(element)

      Inputs:

      -  element, an elliptic curve element in affine form, with
         attributes x and y corresponding to its affine coordinates,
         represented as integers modulo the coordinate field order.

      Outputs:

      A byte array

      Constants:

      field_bytes_length, the number of bytes to represent the scalar
      element, equal to ceil(log2(field.order())).

      1.  byte = 2 if sgn0(element.y) == 0 else 3

      2.  return I2OSP(byte, 1) + I2OSP(x, field_bytes_length)

6.  References

6.1.  Normative References

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/rfc/rfc8017>.

6.2.  Informative References

   [SHA3]     "SHA-3 Standard: Permutation-Based Hash and Extendable-
              Output Functions", n.d.,
              <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.202.pdf>.

Author's Address

   Michele Orrù
   CNRS
   Email: m@orru.net
